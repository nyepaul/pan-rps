#!/bin/bash
###############################################################################
# RPS Restore Script
#
# Restore RPS data from backup archives
#
# Features:
#   - Interactive backup selection
#   - Pre-restore backup of current state
#   - Verification before restore
#   - Selective restore (database only, config only, or full)
#   - Safety checks and confirmations
#
# Usage:
#   ./bin/restore                          # Interactive mode
#   ./bin/restore --backup backup.tar.gz   # Restore specific backup
#   ./bin/restore --list                   # List available backups
#   ./bin/restore --latest                 # Restore latest backup
#
# Author: pan
# Date: 2026-01-20
###############################################################################

set -euo pipefail

# Configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "${SCRIPT_DIR}/.." && pwd)"
BACKUP_DIR="${PROJECT_ROOT}/backups"
LOG_DIR="${PROJECT_ROOT}/logs"
TIMESTAMP=$(date +"%Y%m%d_%H%M%S")

# Restore options
BACKUP_FILE=""
RESTORE_TYPE="full"  # full, database, config
AUTO_CONFIRM=false
LIST_ONLY=false
RESTORE_LATEST=false

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        --backup|-b)
            BACKUP_FILE="$2"
            shift 2
            ;;
        --type|-t)
            RESTORE_TYPE="$2"
            shift 2
            ;;
        --latest)
            RESTORE_LATEST=true
            shift
            ;;
        --list|-l)
            LIST_ONLY=true
            shift
            ;;
        --yes|-y)
            AUTO_CONFIRM=true
            shift
            ;;
        --help|-h)
            echo "Usage: $0 [options]"
            echo ""
            echo "Options:"
            echo "  --backup FILE     Specify backup file to restore"
            echo "  --latest          Restore the most recent backup"
            echo "  --list, -l        List available backups"
            echo "  --type TYPE       Restore type: full, database, config (default: full)"
            echo "  --yes, -y         Skip confirmation prompts"
            echo "  --help, -h        Show this help"
            echo ""
            echo "Examples:"
            echo "  $0 --list"
            echo "  $0 --latest"
            echo "  $0 --backup rps_backup_20260120_120000.tar.gz"
            echo "  $0 --backup backup.tar.gz --type database"
            exit 0
            ;;
        *)
            echo "Unknown option: $1"
            echo "Use --help for usage information"
            exit 1
            ;;
    esac
done

# Logging function
log() {
    local level=$1
    shift
    local message="$*"
    local timestamp=$(date +"%Y-%m-%d %H:%M:%S")

    mkdir -p "${LOG_DIR}"
    echo "[${timestamp}] [${level}] ${message}" >> "${LOG_DIR}/restore.log"

    case $level in
        INFO)
            echo -e "${BLUE}[INFO]${NC} ${message}"
            ;;
        SUCCESS)
            echo -e "${GREEN}[SUCCESS]${NC} ${message}"
            ;;
        WARNING)
            echo -e "${YELLOW}[WARNING]${NC} ${message}"
            ;;
        ERROR)
            echo -e "${RED}[ERROR]${NC} ${message}"
            ;;
        *)
            echo "[${level}] ${message}"
            ;;
    esac
}

# Error handler
error_exit() {
    log ERROR "$1"
    exit 1
}

# List available backups
list_backups() {
    log INFO "Available backups in ${BACKUP_DIR}:"
    echo ""

    if [[ ! -d "${BACKUP_DIR}" ]]; then
        log WARNING "Backup directory does not exist"
        return
    fi

    local backups=($(ls -t "${BACKUP_DIR}"/rps_backup_*.tar.gz 2>/dev/null || true))

    if [[ ${#backups[@]} -eq 0 ]]; then
        log WARNING "No backups found"
        return
    fi

    printf "%-5s %-35s %-12s %-20s\n" "#" "Backup Name" "Size" "Date"
    printf "%-5s %-35s %-12s %-20s\n" "---" "-----------------------------------" "----------" "-------------------"

    local idx=1
    for backup in "${backups[@]}"; do
        local basename=$(basename "$backup")
        local size=$(du -h "$backup" | cut -f1)
        local date=$(stat -c %y "$backup" | cut -d'.' -f1)
        printf "%-5s %-35s %-12s %-20s\n" "$idx" "$basename" "$size" "$date"
        ((idx++))
    done
    echo ""
}

# Get latest backup
get_latest_backup() {
    local latest=$(ls -t "${BACKUP_DIR}"/rps_backup_*.tar.gz 2>/dev/null | head -1)
    if [[ -z "$latest" ]]; then
        error_exit "No backups found"
    fi
    echo "$latest"
}

# Confirm action
confirm() {
    if [[ "${AUTO_CONFIRM}" == "true" ]]; then
        return 0
    fi

    local prompt="$1"
    echo -e "${YELLOW}${prompt} (yes/no):${NC} "
    read -r response
    if [[ "$response" != "yes" ]]; then
        log INFO "Operation cancelled by user"
        exit 0
    fi
}

# Create pre-restore backup
create_pre_restore_backup() {
    log INFO "Creating pre-restore backup of current state..."

    if [[ -f "${PROJECT_ROOT}/data/planning.db" ]]; then
        local pre_backup_name="pre_restore_${TIMESTAMP}"
        local pre_backup_dir="/tmp/${pre_backup_name}"

        mkdir -p "${pre_backup_dir}/data"
        mkdir -p "${pre_backup_dir}/config"

        # Backup current database
        sqlite3 "${PROJECT_ROOT}/data/planning.db" ".backup '${pre_backup_dir}/data/planning.db'"

        # Backup current config
        [[ -f "${PROJECT_ROOT}/.env" ]] && cp "${PROJECT_ROOT}/.env" "${pre_backup_dir}/config/" || true
        [[ -f "${PROJECT_ROOT}/.env.production" ]] && cp "${PROJECT_ROOT}/.env.production" "${pre_backup_dir}/config/" || true

        # Create archive
        cd "${BACKUP_DIR}"
        tar -czf "${pre_backup_name}.tar.gz" -C /tmp "${pre_backup_name}"

        rm -rf "${pre_backup_dir}"

        log SUCCESS "Pre-restore backup created: ${pre_backup_name}.tar.gz"
    else
        log WARNING "No existing database to backup"
    fi
}

# Restore from backup
restore_backup() {
    local backup_path="$1"
    local restore_type="$2"

    if [[ ! -f "$backup_path" ]]; then
        error_exit "Backup file not found: $backup_path"
    fi

    log INFO "Restoring from: $(basename "$backup_path")"
    log INFO "Restore type: ${restore_type}"

    # Verify archive integrity
    log INFO "Verifying backup archive..."
    if ! tar -tzf "$backup_path" > /dev/null 2>&1; then
        error_exit "Backup archive is corrupted or invalid"
    fi
    log SUCCESS "Backup archive verified"

    # Extract to temp directory
    local temp_dir="/tmp/rps_restore_${TIMESTAMP}"
    mkdir -p "$temp_dir"

    log INFO "Extracting backup..."
    tar -xzf "$backup_path" -C "$temp_dir"

    # Find the extracted directory
    local extract_dir=$(find "$temp_dir" -mindepth 1 -maxdepth 1 -type d | head -1)

    if [[ ! -d "$extract_dir" ]]; then
        error_exit "Failed to extract backup"
    fi

    # Show backup metadata
    if [[ -f "${extract_dir}/backup_metadata.txt" ]]; then
        echo ""
        log INFO "=== Backup Metadata ==="
        cat "${extract_dir}/backup_metadata.txt"
        echo ""
    fi

    # Confirm restore
    confirm "Are you sure you want to restore from this backup? This will overwrite current data."

    # Create pre-restore backup
    create_pre_restore_backup

    # Perform restore based on type
    case $restore_type in
        full)
            log INFO "Performing full restore..."

            # Restore database
            if [[ -f "${extract_dir}/data/planning.db" ]]; then
                log INFO "Restoring database..."
                cp "${extract_dir}/data/planning.db" "${PROJECT_ROOT}/data/planning.db"

                # Verify restored database
                if sqlite3 "${PROJECT_ROOT}/data/planning.db" "PRAGMA integrity_check;" | grep -q "ok"; then
                    log SUCCESS "Database restored and verified"
                else
                    error_exit "Restored database failed integrity check"
                fi
            fi

            # Restore configuration
            if [[ -d "${extract_dir}/config" ]]; then
                log INFO "Restoring configuration files..."
                [[ -f "${extract_dir}/config/.env" ]] && cp "${extract_dir}/config/.env" "${PROJECT_ROOT}/" || true
                [[ -f "${extract_dir}/config/.env.production" ]] && cp "${extract_dir}/config/.env.production" "${PROJECT_ROOT}/" || true
                [[ -f "${extract_dir}/config/alembic.ini" ]] && cp "${extract_dir}/config/alembic.ini" "${PROJECT_ROOT}/config/" || true
                [[ -f "${extract_dir}/config/pytest.ini" ]] && cp "${extract_dir}/config/pytest.ini" "${PROJECT_ROOT}/config/" || true
            fi
            ;;

        database)
            log INFO "Restoring database only..."

            if [[ -f "${extract_dir}/data/planning.db" ]]; then
                cp "${extract_dir}/data/planning.db" "${PROJECT_ROOT}/data/planning.db"

                if sqlite3 "${PROJECT_ROOT}/data/planning.db" "PRAGMA integrity_check;" | grep -q "ok"; then
                    log SUCCESS "Database restored and verified"
                else
                    error_exit "Restored database failed integrity check"
                fi
            else
                error_exit "No database found in backup"
            fi
            ;;

        config)
            log INFO "Restoring configuration only..."

            if [[ -d "${extract_dir}/config" ]]; then
                [[ -f "${extract_dir}/config/.env" ]] && cp "${extract_dir}/config/.env" "${PROJECT_ROOT}/" || true
                [[ -f "${extract_dir}/config/.env.production" ]] && cp "${extract_dir}/config/.env.production" "${PROJECT_ROOT}/" || true
                [[ -f "${extract_dir}/config/alembic.ini" ]] && cp "${extract_dir}/config/alembic.ini" "${PROJECT_ROOT}/config/" || true
                [[ -f "${extract_dir}/config/pytest.ini" ]] && cp "${extract_dir}/config/pytest.ini" "${PROJECT_ROOT}/config/" || true
                log SUCCESS "Configuration restored"
            else
                error_exit "No configuration found in backup"
            fi
            ;;

        *)
            error_exit "Unknown restore type: $restore_type"
            ;;
    esac

    # Cleanup
    rm -rf "$temp_dir"

    echo ""
    log SUCCESS "=== Restore Complete ==="
    log INFO "Restore completed successfully"
    log INFO "Log file: ${LOG_DIR}/restore.log"
    echo ""
    log WARNING "Please restart the RPS application for changes to take effect"
    echo ""
}

# Main function
main() {
    # Check if backup directory exists
    if [[ ! -d "${BACKUP_DIR}" ]]; then
        error_exit "Backup directory not found: ${BACKUP_DIR}"
    fi

    # List backups if requested
    if [[ "${LIST_ONLY}" == "true" ]]; then
        list_backups
        exit 0
    fi

    # Get backup file to restore
    if [[ "${RESTORE_LATEST}" == "true" ]]; then
        BACKUP_FILE=$(get_latest_backup)
        log INFO "Using latest backup: $(basename "$BACKUP_FILE")"
    elif [[ -z "${BACKUP_FILE}" ]]; then
        # Interactive mode
        list_backups

        echo -e "${BLUE}Enter backup number to restore (or 'q' to quit):${NC} "
        read -r selection

        if [[ "$selection" == "q" ]]; then
            log INFO "Restore cancelled by user"
            exit 0
        fi

        # Get the selected backup
        local backups=($(ls -t "${BACKUP_DIR}"/rps_backup_*.tar.gz 2>/dev/null || true))
        if [[ $selection -ge 1 && $selection -le ${#backups[@]} ]]; then
            BACKUP_FILE="${backups[$((selection-1))]}"
        else
            error_exit "Invalid selection"
        fi
    else
        # Check if it's a full path or just a filename
        if [[ ! -f "${BACKUP_FILE}" ]]; then
            BACKUP_FILE="${BACKUP_DIR}/${BACKUP_FILE}"
        fi
    fi

    # Perform restore
    restore_backup "${BACKUP_FILE}" "${RESTORE_TYPE}"
}

# Run main function
main

exit 0
